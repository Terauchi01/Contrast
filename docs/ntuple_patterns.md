# N-tupleパターンの設計（5x5盤面）

## 盤面のインデックス
```
 0,  1,  2,  3,  4
 5,  6,  7,  8,  9
10, 11, 12, 13, 14
15, 16, 17, 18, 19
20, 21, 22, 23, 24
```

## 3x3パターンの可能な配置

### 全ての3x3パターン（9箇所）

#### パターン1: 左上 (0,0)
```
[ 0,  1,  2]
[ 5,  6,  7]
[10, 11, 12]
```

#### パターン2: 中上 (1,0)
```
[ 1,  2,  3]
[ 6,  7,  8]
[11, 12, 13]
```

#### パターン3: 右上 (2,0)
```
[ 2,  3,  4]
[ 7,  8,  9]
[12, 13, 14]
```

#### パターン4: 左中 (0,1)
```
[ 5,  6,  7]
[10, 11, 12]
[15, 16, 17]
```

#### パターン5: 中央 (1,1) ★現在使用中
```
[ 6,  7,  8]
[11, 12, 13]
[16, 17, 18]
```

#### パターン6: 右中 (2,1)
```
[ 7,  8,  9]
[12, 13, 14]
[17, 18, 19]
```

#### パターン7: 左下 (0,2)
```
[10, 11, 12]
[15, 16, 17]
[20, 21, 22]
```

#### パターン8: 中下 (1,2)
```
[11, 12, 13]
[16, 17, 18]
[21, 22, 23]
```

#### パターン9: 右下 (2,2)
```
[12, 13, 14]
[17, 18, 19]
[22, 23, 24]
```

---

## 対称性を考慮した本質的に異なるパターン

### 8つの対称変換
1. 恒等変換（そのまま）
2. 90度回転
3. 180度回転
4. 270度回転
5. 水平反転
6. 垂直反転
7. 対角線反転（主対角線）
8. 対角線反転（副対角線）

### 対称性グループ分け

#### グループA: 角（4箇所 → 1つに統合可能）
- パターン1: 左上 `[0,1,2, 5,6,7, 10,11,12]`
- パターン3: 右上 `[2,3,4, 7,8,9, 12,13,14]` （水平反転）
- パターン7: 左下 `[10,11,12, 15,16,17, 20,21,22]` （垂直反転）
- パターン9: 右下 `[12,13,14, 17,18,19, 22,23,24]` （180度回転）

**代表パターン**: 左上

#### グループB: 辺の中央（4箇所 → 1つに統合可能）
- パターン2: 中上 `[1,2,3, 6,7,8, 11,12,13]`
- パターン4: 左中 `[5,6,7, 10,11,12, 15,16,17]` （90度回転）
- パターン6: 右中 `[7,8,9, 12,13,14, 17,18,19]` （90度回転）
- パターン8: 中下 `[11,12,13, 16,17,18, 21,22,23]` （垂直反転）

**代表パターン**: 中上

#### グループC: 中央（1箇所、対称性で不変）
- パターン5: 中央 `[6,7,8, 11,12,13, 16,17,18]`

**代表パターン**: 中央（現在使用中）

---

## 推奨パターン設計

### オプション1: 対称性を最大限活用（3パターン）
メモリ効率的で、対称性を統一的に扱える

```cpp
// パターン1: 角（左上の代表）
[0, 1, 2, 5, 6, 7, 10, 11, 12]

// パターン2: 辺（中上の代表）
[1, 2, 3, 6, 7, 8, 11, 12, 13]

// パターン3: 中央
[6, 7, 8, 11, 12, 13, 16, 17, 18]
```

**メモリ**: 3 × 387,420,489 = 約4.3GB
**利点**: 対称性による汎化、少ないメモリ
**欠点**: 位置依存の特徴を捉えにくい

### オプション2: 全9パターンを使用
位置依存の特徴を最大限に活用

```cpp
// 全9箇所の3x3パターン
パターン1-9（上記参照）
```

**メモリ**: 9 × 387,420,489 = 約12.9GB
**利点**: 位置固有の特徴を学習可能
**欠点**: メモリ大、学習データ必要量増

### オプション3: 2x2パターンの組み合わせ（推奨）
メモリ効率と表現力のバランス

```cpp
// 16個の2x2パターン（9^4 = 6561状態/パターン）
// 全体で約400KB × 16 = 6.4MB

// 左上2x2群（4パターン）
[0, 1, 5, 6]
[1, 2, 6, 7]
[5, 6, 10, 11]
[6, 7, 11, 12]

// 右上2x2群（4パターン）
[2, 3, 7, 8]
[3, 4, 8, 9]
[7, 8, 12, 13]
[8, 9, 13, 14]

// 左下2x2群（4パターン）
[10, 11, 15, 16]
[11, 12, 16, 17]
[15, 16, 20, 21]
[16, 17, 21, 22]

// 右下2x2群（4パターン）
[12, 13, 17, 18]
[13, 14, 18, 19]
[17, 18, 22, 23]
[18, 19, 23, 24]
```

**メモリ**: 16 × 6,561 = 約400KB
**利点**: 非常に少ないメモリ、高速、位置情報も保持
**欠点**: 長距離の相関を捉えにくい

### オプション4: ハイブリッド（バランス型）
中央は3x3、周辺は2x2

```cpp
// 中央3x3（1パターン）
[6, 7, 8, 11, 12, 13, 16, 17, 18]  // 約1.44GB

// 四隅の2x2（4パターン）
[0, 1, 5, 6]      // 左上
[3, 4, 8, 9]      // 右上
[15, 16, 20, 21]  // 左下
[18, 19, 23, 24]  // 右下

// 辺の2x2（4パターン）
[1, 2, 6, 7]      // 上
[7, 8, 12, 13]    // 右
[11, 12, 16, 17]  // 左
[16, 17, 21, 22]  // 下
```

**メモリ**: 1.44GB + 8 × 26KB = 約1.44GB
**利点**: 中央の詳細な特徴 + 周辺の概要
**欠点**: やや複雑

---

## 実装コード例

### 3パターン版（対称性活用）

```cpp
void NTupleNetwork::init_tuples() {
  // パターン1: 左上角
  {
    NTuple pattern;
    pattern.num_cells = 0;
    for (int y = 0; y < 3; ++y) {
      for (int x = 0; x < 3; ++x) {
        pattern.cell_indices[pattern.num_cells++] = y * 5 + x;
      }
    }
    tuples_.push_back(pattern);
  }
  
  // パターン2: 中上辺
  {
    NTuple pattern;
    pattern.num_cells = 0;
    for (int y = 0; y < 3; ++y) {
      for (int x = 1; x < 4; ++x) {
        pattern.cell_indices[pattern.num_cells++] = y * 5 + x;
      }
    }
    tuples_.push_back(pattern);
  }
  
  // パターン3: 中央
  {
    NTuple pattern;
    pattern.num_cells = 0;
    for (int y = 1; y < 4; ++y) {
      for (int x = 1; x < 4; ++x) {
        pattern.cell_indices[pattern.num_cells++] = y * 5 + x;
      }
    }
    tuples_.push_back(pattern);
  }
}
```

### 全9パターン版

```cpp
void NTupleNetwork::init_tuples() {
  // 全9箇所の3x3パターン
  for (int offset_y = 0; offset_y < 3; ++offset_y) {
    for (int offset_x = 0; offset_x < 3; ++offset_x) {
      NTuple pattern;
      pattern.num_cells = 0;
      
      for (int y = 0; y < 3; ++y) {
        for (int x = 0; x < 3; ++x) {
          int cy = offset_y + y;
          int cx = offset_x + x;
          pattern.cell_indices[pattern.num_cells++] = cy * 5 + cx;
        }
      }
      
      tuples_.push_back(pattern);
    }
  }
}
```

### 2x2多数パターン版（推奨）

```cpp
void NTupleNetwork::init_tuples() {
  // 重なりを持つ2x2パターンを網羅的に配置
  for (int offset_y = 0; offset_y < 4; ++offset_y) {
    for (int offset_x = 0; offset_x < 4; ++offset_x) {
      NTuple pattern;
      pattern.num_cells = 0;
      
      for (int y = 0; y < 2; ++y) {
        for (int x = 0; x < 2; ++x) {
          int cy = offset_y + y;
          int cx = offset_x + x;
          pattern.cell_indices[pattern.num_cells++] = cy * 5 + cx;
        }
      }
      
      tuples_.push_back(pattern);
    }
  }
  
  // 合計: 4×4 = 16パターン
  // メモリ: 16 × 9^4 = 16 × 6561 ≈ 400KB
}
```

---

## 推奨アプローチ

**初期段階**: オプション3（2x2多数パターン）
- メモリ効率的（400KB）
- 高速学習
- 基準性能の確認

**強化段階**: オプション1（3パターン）または オプション4（ハイブリッド）
- 適度なメモリ（1.44GB - 4.3GB）
- 対称性による汎化
- より強い性能

**最終段階**: オプション2（全9パターン）
- メモリが許せば
- 最大の表現力
- 最強の性能（理論上）
